/*COMP272 Assignment2 Question 3
*Illustrate what happens when the sequence 1, 5, 2, 4, 3 is added to an empty
*ScapegoatTree, and show where the credits described in the proof of Lemma 8.3 go, and how they
*are used during this sequence of additions.
*
*Arthor:
*Date:
*/

#ifndef _A2Q3_H_									//if not defined
#define _A2Q3_H_

/*
Lemma 8.3 starting with an empty scapegoat tree any sequence of m
add(x) and remove(x) causes at most O(mlogm) time to be used by
rebuild(u) operations.
*
*1 & 2. show the result trees of each insertion in the console output and where the credits go :
*
*According to the question insert 1,5,2,4,3:
*(credits for each node in the brackets)

Insert(1):
root------------------------->

1(0)

Insert(5):
root------------------------->

          5(0)

1(1)

Insert(2):
root------------------------->

          5(1)

                    2(0)

1(2)

Insert(4):
root------------------------->

          5(2)

                              4(0)

                    2(1)

1(3)

Insert(3):
(the before tree generated by myself not printed by code)
Before pay for rebuild:
root------------------------->

                    5(3)

          4(1)

                    3(0)

                              2(2)

1(4)

After pay for rebuild:
root------------------------->

                    5(2)

          4(1)

                    3(0)

                              2(2)

1(4)
*
*
* 3. 
*	m = 5
*	mlogm = 5 * log(5) = 11.6
*
*	The scapegoat tree is rebuilt on 5, 2, 4, 3, so the total avaliable credits: 
*	3+1+2 = 7
*	7 < 11.6
*	Therefore, Lemma 8.3 is correctly shown above.
*	
*
*/

#include<iostream>
#include"SGNode.h"
#include"A2q1.h"
#include"math.h"
using namespace std;

static double const log32(int n) {
	double const log23 = 2.4663034623764317;
	return (double)log23 * log(n);
}

class SGTree {
private:
	SGNode * root; // the root node
	int n; // number of nodes in a tree

public:

	//constructor
	SGTree() {
		root = NULL;
		n = 0;
	}

	/*getRoot()
	*brief: return the root of the tree.
	*/
	SGNode *getRoot() {
		return root;
	}

	/*inorderArray(SGNode *tree, SGNode *nArr[], int i):
	*brief: store nodes in an array in inorder
	*
	*param tree: subroot node
	*param nArry: pointer to a pointer of array pass by reference
	*param i: index
	*
	*/
	int inorderArray(SGNode *tree, SGNode *nArr[], int i) {
		if (tree != NULL) { //inorder traversal starting from the root node "tree"
			i = inorderArray(tree->left, nArr, i);
			nArr[i] = tree; //store the order in an array
			i++;
			return inorderArray(tree->right, nArr, i);
		}
		else { //base case
			return i;
		}
	}

	/*size(SGNode * tree):
	*brief: return the number of nodes in the subtree
	*
	*param tree: subroot node
	*
	*/
	int size(SGNode * tree) {
		if (tree == NULL) //null root means no node in the tree
			return 0;
		return 1 + size(tree->left) + size(tree->right);
	}

	/*insertReturnDepth(SGNode * tree):
	*brief: insert a node to a BST and return its depth in the tree.
	*
	*param tree: node to be inserted
	*
	*/
	int insertReturnDepth(SGNode * tree) {
		SGNode *tmpN = root;
		int depth = 0;
		if (tmpN == NULL) {//build a tree
			root = tree; //create a root
			n++;//increment size
		}
		else {//BST insert
			bool finish = false;
			while (!finish) {
				if (tree->data < tmpN->data) {//new data is less than that stored in the node
					tmpN->credits++;//increament credit
					if (tmpN->left == NULL) {
						tmpN->left = tree;
						tree->parent = tmpN;
						finish = true;
					}
					else {
						tmpN = tmpN->left; //go to left
					}
				}
				else if (tree->data > tmpN->data) {//new data is larger than that stored in the node
					tmpN->credits++;
					if (tmpN->right == NULL) {
						tmpN->right = tree;
						tree->parent = tmpN;
						finish = true;
					}
					else {
						tmpN = tmpN->right;
					}
				}
				else { //does not allow duplicate node
					return -1;
				}
				depth++; //increment depth
			}
			n++;

		}
		return depth;
		
	}

	/*buildWithBalance:
	*brief: build a balance tree from an inorder stored node array 
	*
	*param nArr: a pointer to array pointer
	*param sn: number of nodes in array
	*param i: start index
	*
	*/
	SGNode *buildWithBalance(SGNode **nArr, int i, int sn) {
		if (sn == 0) {
			return NULL;
		}
		else {
			int m = sn / 2;
			//elements 0th to m-1th will be in the left subtree
			nArr[i + m]->left = buildWithBalance(nArr, i, m);

			if (nArr[i + m]->left != NULL) //set parent
				nArr[i + m]->left->parent = nArr[i + m];

			//elements mth to nth will be in the right subtree
			nArr[i + m]->right = buildWithBalance(nArr, i + m + 1, sn - m - 1);
			
			if (nArr[i + m]->right != NULL) //set parent
				nArr[i + m]->right->parent = nArr[i + m];

			return nArr[i + m];

		}
	}

	/*rebuild(SGNode *tree):
	*brief: rebuild a balanced tree
	*from original subtree rooted at tree
	*
	*param tree: scapegoat node
	*
	*/
	void rebuild(SGNode *tree) {
		tree->credits--;
		int sn = size(tree);
		SGNode **arr = new SGNode *[sn];
		SGNode *p = tree->parent;
		inorderArray(tree, arr, 0); //store to a inorder array
		if (p == NULL) {//parent is NULL
			root = buildWithBalance(arr, 0, sn); //update root
			root->parent = NULL;
		}
		else if (p->right == tree) {//the node is right child
			p->right = buildWithBalance(arr, 0, sn);
			p->right->parent = p;
		}
		else { //the node is left child
			p->left = buildWithBalance(arr, 0, sn);
			p->left->parent = p;
		}

	}

	/*insert(double x):
	*brief: insert a new node with data x to the tree
	*
	*param x: a new value
	*
	*/
	bool insert(double x) {
		SGNode *tmpN = newSGNode(x);

		//insert the new node and get the depth
		int d = insertReturnDepth(tmpN);
		if (d < 0) {
			return false;
		}
		else {
			//if it is unbalaned
			if (d > log32(n)) {
				SGNode *p = tmpN->parent;
				while ((double)(size(tmpN)) / size(p) <= 2.0 / 3.0) { //find the scapegoat node
					tmpN = p;
					p = p->parent;
				}
				//rebiuld the tree rooted at the scapegoat
				rebuild(p);
			}
			return true;
		}
	}



};

/*printSGTreeUtil(SGNode *tree, int space, bool displayCredits = false):
*brief: Utility function to print a scapegoat tree on the console
*
*param tree: a node in a scapegoat tree
*param space: space between each level
*
*/
void printSGTreeUtil(SGNode *tree, int space, bool displayCredits = false) {
	if (tree == NULL) {
		return;
	}

	space += 10;

	printSGTreeUtil(tree->right, space, displayCredits);
	cout << endl;
	for (int i = 10; i < space; i++)
		cout << " ";
	if(displayCredits)
		cout << tree->data << "(" << tree->credits << ")" << endl;
	else
		cout << tree->data << endl;

	printSGTreeUtil(tree->left, space, displayCredits);
}
/*printSGTree(SGNode *tree):
*brief: A function to print a scapegoat tree on the console (call the utility function)
*
*/
void printSGTree(SGNode *tree, bool displayCredits = false) {
	printSGTreeUtil(tree, 0, displayCredits);
}

#endif
